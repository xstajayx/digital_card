(function () {
  function ByteArray() {
    this.data = [];
  }
  ByteArray.prototype.writeByte = function (val) {
    this.data.push(val & 255);
  };
  ByteArray.prototype.writeUTF = function (str) {
    for (var i = 0; i < str.length; i++) {
      this.writeByte(str.charCodeAt(i));
    }
  };
  ByteArray.prototype.getData = function () {
    return new Uint8Array(this.data);
  };

  function writeWord(ba, value) {
    ba.writeByte(value & 255);
    ba.writeByte((value >> 8) & 255);
  }

  function buildPalette() {
    var colors = [];
    var steps = [0, 51, 102, 153, 204, 255];
    for (var r = 0; r < steps.length; r++) {
      for (var g = 0; g < steps.length; g++) {
        for (var b = 0; b < steps.length; b++) {
          colors.push([steps[r], steps[g], steps[b]]);
        }
      }
    }
    while (colors.length < 256) {
      colors.push([0, 0, 0]);
    }
    return colors;
  }

  function mapColor(r, g, b) {
    var rIndex = Math.round(r / 51);
    var gIndex = Math.round(g / 51);
    var bIndex = Math.round(b / 51);
    return rIndex * 36 + gIndex * 6 + bIndex;
  }

  function lzwEncode(minCodeSize, indices) {
    var clearCode = 1 << minCodeSize;
    var endCode = clearCode + 1;
    var dict = new Map();
    var dictSize = endCode + 1;
    var codeSize = minCodeSize + 1;

    function resetDict() {
      dict = new Map();
      dictSize = endCode + 1;
      codeSize = minCodeSize + 1;
    }

    resetDict();

    var output = [];
    var cur = 0;
    var bits = 0;

    function writeCode(code) {
      cur |= code << bits;
      bits += codeSize;
      while (bits >= 8) {
        output.push(cur & 255);
        cur >>= 8;
        bits -= 8;
      }
    }

    writeCode(clearCode);

    var prefix = String(indices[0]);
    for (var i = 1; i < indices.length; i++) {
      var k = indices[i];
      var key = prefix + ',' + k;
      if (dict.has(key)) {
        prefix = key;
      } else {
        var prefixCode = prefix.indexOf(',') === -1 ? parseInt(prefix, 10) : dict.get(prefix);
        writeCode(prefixCode);
        dict.set(key, dictSize++);
        prefix = String(k);
        if (dictSize >= 1 << codeSize && codeSize < 12) {
          codeSize++;
        }
        if (dictSize >= 4096) {
          writeCode(clearCode);
          resetDict();
        }
      }
    }

    var lastCode = prefix.indexOf(',') === -1 ? parseInt(prefix, 10) : dict.get(prefix);
    writeCode(lastCode);
    writeCode(endCode);

    if (bits > 0) {
      output.push(cur & 255);
    }

    return output;
  }

  function writeSubBlocks(ba, data) {
    var offset = 0;
    while (offset < data.length) {
      var blockSize = Math.min(255, data.length - offset);
      ba.writeByte(blockSize);
      for (var i = 0; i < blockSize; i++) {
        ba.writeByte(data[offset + i]);
      }
      offset += blockSize;
    }
    ba.writeByte(0);
  }

  function GIFEncoder(width, height) {
    this.width = width;
    this.height = height;
    this.frames = [];
  }

  GIFEncoder.prototype.addFrame = function (imageData, delay) {
    this.frames.push({ imageData: imageData, delay: delay });
  };

  GIFEncoder.prototype.render = function () {
    var ba = new ByteArray();
    ba.writeUTF('GIF89a');
    writeWord(ba, this.width);
    writeWord(ba, this.height);
    ba.writeByte(0x00); // No global color table
    ba.writeByte(0);
    ba.writeByte(0);

    var palette = buildPalette();

    for (var f = 0; f < this.frames.length; f++) {
      var frame = this.frames[f];
      // Graphics Control Extension
      ba.writeByte(0x21);
      ba.writeByte(0xF9);
      ba.writeByte(4);
      ba.writeByte(0);
      writeWord(ba, Math.round(frame.delay / 10));
      ba.writeByte(0);
      ba.writeByte(0);

      // Image Descriptor
      ba.writeByte(0x2C);
      writeWord(ba, 0);
      writeWord(ba, 0);
      writeWord(ba, this.width);
      writeWord(ba, this.height);
      ba.writeByte(0x87); // Local color table 256 colors

      for (var i = 0; i < palette.length; i++) {
        ba.writeByte(palette[i][0]);
        ba.writeByte(palette[i][1]);
        ba.writeByte(palette[i][2]);
      }

      var indices = [];
      var data = frame.imageData.data;
      for (var p = 0; p < data.length; p += 4) {
        var alpha = data[p + 3];
        if (alpha === 0) {
          indices.push(0);
        } else {
          indices.push(mapColor(data[p], data[p + 1], data[p + 2]));
        }
      }

      var minCodeSize = 8;
      ba.writeByte(minCodeSize);
      var lzwData = lzwEncode(minCodeSize, indices);
      writeSubBlocks(ba, lzwData);
    }

    ba.writeByte(0x3B);
    return ba.getData();
  };

  function GIF(options) {
    this.options = options || {};
    this.frames = [];
    this.handlers = {};
  }

  GIF.prototype.addFrame = function (canvas, options) {
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    this.frames.push({ imageData: imageData, delay: options.delay || 100 });
  };

  GIF.prototype.on = function (event, handler) {
    this.handlers[event] = handler;
  };

  GIF.prototype.render = function () {
    var width = this.options.width;
    var height = this.options.height;
    var encoder = new GIFEncoder(width, height);
    for (var i = 0; i < this.frames.length; i++) {
      encoder.addFrame(this.frames[i].imageData, this.frames[i].delay);
    }
    var data = encoder.render();
    var blob = new Blob([data], { type: 'image/gif' });
    if (this.handlers.finished) {
      this.handlers.finished(blob);
    }
  };

  window.GIF = GIF;
})();
